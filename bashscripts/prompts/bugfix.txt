# Bug Fixing Guidelines and Best Practices

## Core Principles
- Always analyze the root cause through thorough code and context analysis
- Follow a systematic approach to bug resolution
- Maintain documentation integrity throughout the process
- Respect module boundaries and responsibilities

## Documentation Process
1. **Before Making Changes**
   - Study the documentation in the module's `docs` folder (not the root `docs`)
   - Create bidirectional links between module and root documentation
   - Update relevant documentation before implementing fixes

## Code Organization
- **Namespace Structure**:
  - Use `Modules\<module>\` (NOT `Modules\<module>\App\`)
  - Filament components: `Modules\<module>\Filament`
  - Never extend Filament classes directly - use XotBase classes

## Translation Guidelines
- **Never** use `->label()` directly
- Use the LangServiceProvider for all translations
- Store translations in: `Modules/<module>/lang/<language>/`
- Follow the expanded translation structure

## Common Fix Patterns
1. **Resource Classes**:
   - Remove `getTableColumn`, `getTableFilters`, `getBulkActions` if empty
   - Remove `getPages` if it only returns default pages
   - Use associative arrays with string keys for all methods

2. **Form Handling**:
   - Convert array options to enums for type safety
   - Use proper validation rules
   - Implement proper error handling

## Implementation Strategy
1. **Analysis Phase**:
   - Understand the error context
   - Check related components
   - Review recent changes

2. **Documentation Update**:
   - Update module documentation
   - Create/update root documentation
   - Add bidirectional links

3. **Implementation**:
   - Follow DRY and KISS principles
   - Consider architectural implications
   - Maintain backward compatibility

4. **Testing**:
   - Test the fix
   - Check for regressions
   - Update tests if needed

## Quality Assurance
- Run PHPStan (level 10)
- Ensure PSR-12 compliance
- Verify type safety
- Check for security implications

## Best Practices
- Keep changes minimal and focused
- Document decisions and rationale
- Consider performance implications
- Follow the principle of least surprise

## Common Pitfalls to Avoid
- Direct Filament class extensions
- Hardcoded strings and labels
- Ignoring module boundaries
- Skipping documentation updates

## Review Process
- Self-review changes
- Check for similar issues in the codebase
- Update relevant documentation
- Consider creating automated tests

# Gestione ParseError: metodi fuori dalla classe in PHP

## Causa
Un errore di tipo `ParseError: syntax error, unexpected token "protected", expecting end of file` si verifica quando una funzione (es. `protected function getUserTypeOptions()`) viene dichiarata **fuori dal blocco della classe**. Questo accade spesso dopo una parentesi graffa di chiusura `}` della classe, lasciando il metodo "orfano".

## Soluzione
- Spostare sempre i metodi all'interno della classe corretta.
- Verificare che la parentesi graffa di chiusura della classe sia l'ultima istruzione del file.
- Se il metodo non serve più, eliminarlo.

## Best Practice
- Ogni funzione/membro deve essere dichiarato **all'interno** della classe.
- La chiusura della classe (`}`) deve essere l'ultima istruzione del file.
- Dopo ogni refactor, controllare che non restino metodi orfani.
- Usare sempre editor con linting attivo per prevenire errori di sintassi.

## Esempio (corretto)
```php
class Example {
    public function foo() {}
    // ...
} // <--- questa DEVE essere l'ultima parentesi graffa
```

## Caso reale
- Errore su `Modules/User/app/Filament/Widgets/Auth/RegisterWidget.php` risolto spostando la funzione orfana all'interno della classe o eliminandola se non più necessaria.

## Filosofia
- La coerenza strutturale del codice è fondamentale per la manutenibilità e la prevenzione di bug sistemici.
- Ogni correzione va documentata nella cartella docs più vicina e nel knowledge base dei bugfix.

# Gestione ParseError: metodi fuori dalla classe in PHP

## Causa
Un errore di tipo `ParseError: syntax error, unexpected token "protected", expecting end of file` si verifica quando una funzione (es. `protected function getUserTypeOptions()`) viene dichiarata **fuori dal blocco della classe**. Questo accade spesso dopo una parentesi graffa di chiusura `}` della classe, lasciando il metodo "orfano".

## Soluzione
- Spostare sempre i metodi all'interno della classe corretta.
- Verificare che la parentesi graffa di chiusura della classe sia l'ultima istruzione del file.
- Se il metodo non serve più, eliminarlo.

## Best Practice
- Ogni funzione/membro deve essere dichiarato **all'interno** della classe.
- La chiusura della classe (`}`) deve essere l'ultima istruzione del file.
- Dopo ogni refactor, controllare che non restino metodi orfani.
- Usare sempre editor con linting attivo per prevenire errori di sintassi.

## Esempio (corretto)
```php
class Example {
    public function foo() {}
    // ...
} // <--- questa DEVE essere l'ultima parentesi graffa
```

## Caso reale
- Errore su `Modules/User/app/Filament/Widgets/Auth/RegisterWidget.php` risolto spostando la funzione orfana all'interno della classe o eliminandola se non più necessaria.

## Filosofia
- La coerenza strutturale del codice è fondamentale per la manutenibilità e la prevenzione di bug sistemici.
- Ogni correzione va documentata nella cartella docs più vicina e nel knowledge base dei bugfix.
<<<<<<< HEAD


=======
Please remember ___ @Memory . Prima di correggere qualsiasi errore, è fondamentale comprendere la causa radice attraverso un'analisi approfondita del codice e del contesto. Il processo inizia sempre con l'aggiornamento della documentazione nella cartella docs più vicina all'errore (escludendo la cartella docs della root del progetto), seguito dalla creazione di collegamenti bidirezionali con i file della cartella docs principale per mantenere la coerenza informativa. È essenziale studiare approfonditamente tutte le cartelle docs coinvolte prima di implementare qualsiasi correzione, procedendo poi con le correzioni secondo un ordine di priorità logico e strategico. Il namespace corretto per i moduli Filament è sempre Modules<nome modulo>\Filament e mai Modules<nome modulo>\App\Filament, anche quando si lavora nella cartella laravel/Modules/<nome modulo>/app/Filament. Per le traduzioni, è fondamentale comprendere che il metodo ->label() non deve mai essere utilizzato perché crea un accoppiamento stretto tra il codice e le stringhe di traduzione hardcoded, violando il principio di separazione delle responsabilità e rendendo impossibile la gestione centralizzata delle traduzioni. Invece, il sistema utilizza il LangServiceProvider che automaticamente intercetta e risolve le chiavi di traduzione attraverso i file di traduzione specifici del modulo situati in Modules/<nome modulo>/lang/<lingua>, permettendo così una gestione dinamica, scalabile e mantenibile delle traduzioni multilingue. Questo approccio garantisce che ogni modulo mantenga le proprie traduzioni in modo isolato e coerente, evitando conflitti di naming e permettendo override specifici per contesto. Il LangServiceProvider funziona attraverso un sistema di convenzioni dove le chiavi di traduzione vengono automaticamente risolte basandosi sul nome della classe, del metodo e del contesto di utilizzo, eliminando completamente la necessità di specificare manualmente le label e creando un sistema self-documenting dove le traduzioni sono organizzate logicamente. Le regole generali devono essere documentate nella cartella docs del modulo Xot con collegamenti bidirezionali dagli altri moduli per evitare duplicazioni e mantenere la sincronizzazione. Gli elementi frontend devono essere posizionati nel modulo Cms per rispettare la separazione delle responsabilità. Ogni modulo ha uno scopo specifico ben definito che deve essere rispettato rigorosamente. È necessario aggiornare continuamente la comprensione delle cartelle docs, delle regole e delle memorie per mantenere un ecosistema coerente. Quando si modificano file, progettarli sempre considerando che dovranno superare controlli di qualità elevati in futuro, seguendo i principi DRY (Don't Repeat Yourself) e KISS (Keep It Simple, Stupid). Considerare sempre le implicazioni filosofiche, politiche, religiose e zen nelle soluzioni implementate per garantire un approccio olistico dove ogni decisione tecnica riflette una comprensione profonda dell'architettura sistemica. Quando si trova un errore, correggere tutti i file che contengono lo stesso problema per evitare inconsistenze sistemiche. Non estendere mai classi Filament direttamente, ma utilizzare sempre una classe astratta con lo stesso nome preceduto dal prefisso XotBase, rispettando la struttura del namespace di Filament (esempio: se una classe estendeva \Filament\Resources\Pages\Page ora deve estendere Modules\Xot\Filament\Resources\Pages\XotBasePage). Le classi che estendono XotBaseResource non devono implementare getTableColumn, getTableFilters, getBulkActions, table, e se getPages restituisce solo index,create,edit o index,create,edit,view, rimuovere anche il metodo getPages. Se in un form la select ha opzioni che sono un array, convertire agli enum per maggiore type safety e per beneficiare dell'autocompletamento dell'IDE. Il namespace corretto è Modules\<nome>\ e non Modules\<nome>\App\ per mantenere una struttura modulare pulita e coerente. I metodi getFormSchema, getTableActions, getTableColumns, getTableFilters, getTableBulkActions devono sempre restituire un array associativo con chiavi di tipo stringa per garantire l'identificazione univoca degli elementi e permettere l'override selettivo delle configurazioni. È fondamentale ragionare sul perché di ogni errore, comprendere la causa radice attraverso l'analisi del flusso di esecuzione, degli stack trace e del contesto di utilizzo, aggiornare e studiare le cartelle docs coinvolte, aggiornare le regole personali, le memorie, i file .windsurf/rules, .cursor/rules, .cursor/memories, implementando tutto il possibile per creare un sistema di prevenzione errori che apprende dall'esperienza. Dopo l'implementazione della correzione principale, correggere sempre tutti gli altri file che presentano lo stesso problema attraverso ricerche sistematiche nel codebase per mantenere la coerenza sistemica. Le classi che estendevano \Filament\Resources\Pages\ListRecords devono ora estendere \Modules\Xot\Filament\Resources\Pages\XotBaseListRecords e non XotBasePage per rispettare la gerarchia specifica e beneficiare delle funzionalità ottimizzate per le liste. È importante ricordare che protected $casts e protected $dates sono deprecati nelle versioni moderne di Laravel a favore di protected function casts() e l'utilizzo degli accessor/mutator moderni. Nelle cartelle docs, i file e le sottocartelle non devono contenere caratteri maiuscoli ad eccezione di README.md per mantenere la consistenza nella denominazione e rispettare le convenzioni Unix. Per ogni errore, è necessario leggere attentamente tutto il codice del progetto e tutte le cartelle docs incluse le sottocartelle, ragionare profondamente sulla filosofia architetturale sottostante, comprendere la logica di business, le implicazioni politiche delle decisioni tecniche, l'aspetto religioso della coerenza del codice e lo zen dell'equilibrio tra semplicità e funzionalità, aggiornare le cartelle docs coinvolte con nuove intuizioni, studiare nuovamente la documentazione aggiornata per interiorizzare i cambiamenti e solo dopo implementare la correzione con un ragionamento che considera l'impatto sistemico. La documentazione specifica dei moduli deve essere posizionata nella cartella docs del rispettivo modulo per mantenere la coesione logica, mentre nella cartella docs della root del progetto devono essere presenti file con collegamenti alla documentazione specifica creando un sistema di navigazione ipertestuale che facilita la scoperta delle informazioni. I file .mdc devono essere posizionati nelle cartelle .windsurf/rules e .cursor/rules della root del progetto per garantire l'accessibilità agli strumenti di sviluppo e mantenere la sincronizzazione delle regole tra diversi editor. Tutti i file .php devono contenere declare(strict_types=1); per garantire il type checking rigoroso e prevenire errori di tipo runtime. Gli step degli wizard devono essere implementati in funzioni separate per rispettare i principi del clean code, migliorare la testabilità e facilitare la manutenzione attraverso la decomposizione funzionale. Il processo di correzione deve sempre iniziare con l'aggiornamento della documentazione per cristallizzare la comprensione del problema, seguito dallo studio approfondito della documentazione aggiornata per interiorizzare le nuove informazioni, la scrittura nella documentazione di ciò che si intende implementare per chiarire l'approccio, una riflessione critica per verificare che sia la scelta ottimale considerando alternative e trade-off, una discussione interna silenziosa per individuare la politica architetturale, la filosofia del design, la logica di business e l'aspetto zen dell'equilibrio sistemico, un ulteriore aggiornamento delle cartelle docs coinvolte con le nuove intuizioni e solo infine l'implementazione della correzione con piena consapevolezza delle implicazioni. Le classi che estendono \Modules\Xot\Filament\Resources\Pages\XotBaseListRecords devono implementare il metodo getTableColumns() che deve restituire un array con chiavi di tipo stringa dove ogni chiave identifica univocamente una colonna, e le colonne da includere non devono essere inventate ma ricavate sistematicamente dal modello Eloquent attraverso l'analisi degli attributi fillable, delle relazioni definite, o dalla migrazione corrispondente per garantire l'accuratezza dei dati e la coerenza con la struttura del database. Nelle cartelle docs, prima di creare un nuovo file, verificare sempre attraverso ricerche sistematiche che non esista già un file che tratti lo stesso argomento per evitare frammentazione delle informazioni, e nel caso esista, aggiungere la documentazione al file esistente mantenendo la coerenza informativa e creando una struttura logica che facilita la consultazione. Non estendere mai Illuminate\Support\ServiceProvider ma utilizzare sempre Modules\Xot\Providers\XotBaseServiceProvider poiché XotBaseServiceProvider implementa già molte funzionalità comuni come il register automatico delle routes, la gestione delle configurazioni, il binding dei servizi e la registrazione delle traduzioni, evitando duplicazioni di codice e garantendo comportamenti consistenti across tutti i moduli. Utilizzare preferibilmente Spatie Laravel Data per la gestione dei Data Transfer Objects garantendo type safety e validazione automatica, evitare l'uso di services tradizionali che creano accoppiamento stretto, preferendo invece Spatie QueableActions che implementano il pattern Command con supporto per queue, retry logic e job batching, mantenendo l'aderenza alla filosofia Laravel con Laraxot per soluzioni efficienti, testabili e manutenibili che seguono i principi SOLID. Il codice deve essere sempre solido attraverso test comprehensivi, robusto attraverso error handling appropriato e rigorosamente tipizzato utilizzando union types, generics e type hints specifici invece di mixed quando possibile. Se si creano file .sh, posizionarli in una sottocartella di bashscripts per mantenere l'organizzazione del progetto e facilitare la gestione degli script di automazione. Dopo ogni bugfix, scrivere test di regressione che verifichino sia il fix specifico che l'assenza di side effects, verificare che non causi problemi in moduli interconnessi attraverso test di integrazione, documentare pattern e anti-pattern identificati per creare una knowledge base che previene errori futuri, non limitandosi alla semplice correzione ma creando valore educativo per il team. Registrare il contesto completo in cui si è verificato il bug includendo versione delle dipendenze, configurazione dell'ambiente, condizioni di trigger specifiche, stack trace completo e scenario utente, verificare eventuali aggiornamenti necessari nelle dipendenze o configurazioni per prevenire regressioni future. Utilizzare commit message standardizzati seguendo rigorosamente il formato fix(modulo): breve descrizione del problema risolto per mantenere la tracciabilità e facilitare la generazione automatica di changelog. Categorizzare sistematicamente i bugfix per identificare aree problematiche nel tempo, pattern ricorrenti e opportunità di refactoring, utilizzando queste informazioni per migliorare continuamente l'architettura e i processi di sviluppo. Aggiornare costantemente le regole personali e le memorie (.windsurf/rules, .cursor/rules, .cursor/memories, ~/.codeium/windsurf/memories/global_rules.md) per creare un sistema di intelligenza artificiale personale che apprende dall'esperienza e previene errori futuri attraverso l'accumulo di conoscenza procedurale. Analizzare sempre anche classi estese e traits correlati per una comprensione completa dell'ecosystem, tracciando le dipendenze e identificando potenziali punti di fallimento o accoppiamento eccessivo. Eliminare metodi getHeaderActions che restituiscono solo DeleteAction per semplificare il codice e ridurre la superficie di attacco per potenziali bug, preferendo implementazioni più specifiche e granulari. Non modificare mai phpstan.neon per mantenere la stabilità della configurazione di analisi statica e garantire che tutti i developer lavorino con gli stessi standard di qualità del codice. Scrivere sempre codice strutturato per superare il massimo livello di controllo statico disponibile, seguendo rigorosamente PSR-12 per la formattazione, utilizzando type hints espliciti e specifici per ogni parametro e return type, definendo property types quando possibile, utilizzando mixed solo come ultima risorsa quando l'analisi statica non può determinare un tipo più specifico e sempre documentando il motivo di questa scelta nei commenti del codice.al posto di FileUpload usa https://filamentphp.com/plugins/filament-spatie-media-library, https://github.com/filamentphp/spatie-laravel-media-library-plugin . capisci logica, filosofia, religione, politica, zen, epistemologia, ontologia, etica, estetica, fenomenologia, ermeneutica, taoismo, buddhismo, stoicismo, minimalismo spirituale, governance, democrazia, autorità, trasparenza, accountability, inclusività, diversità, potere, controllo, neutralità tecnologica, bias, psicologia cognitiva, behaviorismo, gestalt, flow state, bias cognitivi, euristiche, antropologia digitale, sociologia del lavoro, comunicazione interculturale, norme sociali, convenzioni, capitale sociale, reputazione, teoria dei giochi, economia dell’attenzione, ROI, value engineering, sostenibilità economica, costi nascosti, debito tecnico, sostenibilità ambientale, efficienza energetica, economia circolare, impatto carbonico, obsolescenza programmata, longevità, cronologia, sincronicità, asincronia, persistenza, memoria, cicli di vita, evoluzione, legacy, modernità, topologia, geometria dell’informazione, architettura fisica, architettura logica, distribuzione geografica, prossimità, latenza, semantica, sintassi, pragmatica, semiotica, metalinguaggio, design patterns, creatività, improvvisazione, jazz programming, ritmo, cadenza, composizione, armonia, logica formale, inferenza, teoria dei grafi, algebra computazionale, geometria computazionale, statistica, probabilità, teoria dell’informazione, termodinamica, entropia, meccanica quantistica, indeterminazione, fisica delle particelle, teoria del caos, leggi di conservazione, evoluzione, selezione naturale, ecosistemi software, DNA del codice, immunità, difese, metabolismo, cicli vitali, composizione chimica, reazioni chimiche, catalizzatori, equilibrio chimico, legami molecolari, tossicità del codice. Per le traduzioni usiamo https://filamentphp.com/plugins/filament-spatie-translatable, https://github.com/filamentphp/spatie-laravel-translatable-plugin , e nei blocchi perciò non scriviamo $title[app()->locale()] ma semplicemente $title, perché si arrangia il pacchetto a fare quelle cose in automatico, ai blocchi passiamo l'array data, percio' al blocco arrivano direttamente le variabile percio' non $data['title'] ma solo dobbiamo usare $title, per mantenere la semplicità
Please remember ___ @Memory . Prima di correggere un errore, comprendi la causa, aggiorna la documentazione nella cartella docs più vicina all'errore (esclusa la cartella docs della root), crea collegamenti bidirezionali ai file della cartella docs principale, studia approfonditamente le cartelle docs coinvolte prima di implementare qualsiasi correzione; procedi con le correzioni secondo un ordine di priorità che ritieni opportuno; ricorda che il namespace corretto è Modules<nome modulo>\Filament e non Modules<nome modulo>\App\Filament anche quando lavori nella cartella laravel/Modules/<nome modulo>/app/Filament; utilizza i file di traduzione del modulo dentro Modules/<nome modulo>/lang/<lingua> anziché ->label(); le regole generali vanno documentate nella cartella docs del modulo Xot con collegamenti bidirezionali dagli altri moduli; gli elementi frontend vanno nel modulo Cms; ogni modulo ha uno scopo specifico; aggiorna continuamente la tua comprensione delle cartelle docs, delle regole e delle memorie; quando modifichi file, progettali pensando che dovranno superare controlli di qualità elevati in futuro; segui i principi DRY (Don't Repeat Yourself) e KISS (Keep It Simple, Stupid); considera sempre le implicazioni di politica, filosofia, religione e zen nelle tue soluzioni; quando trovi un errore, correggi tutti i file che contengono lo stesso problema. Prima di correggere un errore, comprendi la causa, aggiorna la cartella docs più vicina all'errore (esclusa quella root) e crea collegamenti bidirezionali con la docs root, creando nuovi file quando necessario. Solo dopo aver studiato approfonditamente le docs coinvolte, implementa la correzione con ordine e priorità a tua scelta. Ricorda: il namespace corretto è Modules<nome modulo>\Filament (non App\Filament); utilizza i file di traduzione in Modules/<nome modulo>/lang/<lingua> invece di ->label(); le regole generali vanno nella docs del modulo Xot con collegamenti bidirezionali dagli altri moduli; contenuti frontend nel modulo Cms. Scrivi sempre codice strutturato per superare il massimo livello di controllo statico, seguendo PSR-12, con tipi espliciti ben definiti, usando mixed solo come ultima risorsa. Dopo ogni bugfix, scrivi test di regressione e verifica che non causi problemi in moduli interconnessi. Documenta pattern e anti-pattern identificati, non solo la correzione. Registra il contesto in cui si è verificato il bug (versione, ambiente, condizioni di trigger) e verifica eventuali aggiornamenti necessari nelle dipendenze o configurazioni. Utilizza commit message standardizzati (fix(modulo): breve descrizione). Categorizza i bugfix per identificare aree problematiche nel tempo. Aggiorna costantemente le tue rules, memories (.windsurf/rules, .cursor/rules, .cursor/memories, ~/.codeium/windsurf/memories/global_rules.md) per evitare errori futuri. Analizza anche classi estese e traits correlati. Elimina metodi getHeaderActions che restituiscono solo DeleteAction. Non modificare mai phpstan.neon. ti ricordo che i files .mdc vanno sempre dentro /var/www/html/ptvx/.cursor/rules e dentro /var/www/html/ptvx/.windsurf/rules, controlla nella documentazione di cursor e di windsurf come fare il miglior lavoro,  analizza piu' a fondo e continua a creare i files .mdc per cursor e per windsurf, prima di creare un files dentro la cartella docs , controlla che non ci sia gia' un file che parli dello stesso argomento, dentro le cartelle docs non e' bello che ci siano piu' files che parlino degli stessi argomenti. Always respond in italian, Use the 'docs' folder as your primary memory source. Continuously update and study this folder to ensure it remains current with all necessary information. Your code must be solid, robust, and strictly typed. Prefer the use of Spatie Laravel Data and avoid using services—prefer Spatie QueableActions instead. Embrace the Laravel philosophy with Laraxot for efficient and maintainable solutions. non estendiamo Illuminate\Support\ServiceProvider  ma estendiamo  Modules\Xot\Providers\XotBaseServiceProvider  e moltissime cose le fa XotBaseServiceProvider e percio' cerchiamo di non farle fare 2 volte. dentro le cartelle docs ne i files ne le sottocartelle devono avere caratteri maiuscoli ad eccezzione di README.md , controlla e correggi. se crei files .sh vanno una sottocartella di bashscripts. dentro le cartelle docs ne i files ne le sottocartelle devono contenere caratteri maiuscoli ad accezzione di README.md ,  capisci la regola, il perche' la filosofia, la logica , aggiorna le tue rules le tue memories e tutto quello che serve per non fare mai piu' questo errore e correggi, se devi fare uno script , gli scripts vanno tutti in una sottocartella di bashscripts, prima di crearne uno controlla che non esista gia' un o script che faccia al tuo caso. gli script non vanno in bashscripts, ma in una sottocartella di bashscripts
=======
Please remember ___ @Memory . Prima di correggere qualsiasi errore, è fondamentale comprendere la causa radice attraverso un'analisi approfondita del codice e del contesto. Il processo inizia sempre con l'aggiornamento della documentazione nella cartella docs più vicina all'errore (escludendo la cartella docs della root del progetto), seguito dalla creazione di collegamenti bidirezionali con i file della cartella docs principale per mantenere la coerenza informativa. È essenziale studiare approfonditamente tutte le cartelle docs coinvolte prima di implementare qualsiasi correzione, procedendo poi con le correzioni secondo un ordine di priorità logico e strategico. Il namespace corretto per i moduli Filament è sempre Modules<nome modulo>\Filament e mai Modules<nome modulo>\App\Filament, anche quando si lavora nella cartella laravel/Modules/<nome modulo>/app/Filament. Per le traduzioni, è fondamentale comprendere che il metodo ->label() non deve mai essere utilizzato perché crea un accoppiamento stretto tra il codice e le stringhe di traduzione hardcoded, violando il principio di separazione delle responsabilità e rendendo impossibile la gestione centralizzata delle traduzioni. Invece, il sistema utilizza il LangServiceProvider che automaticamente intercetta e risolve le chiavi di traduzione attraverso i file di traduzione specifici del modulo situati in Modules/<nome modulo>/lang/<lingua>, permettendo così una gestione dinamica, scalabile e mantenibile delle traduzioni multilingue. Questo approccio garantisce che ogni modulo mantenga le proprie traduzioni in modo isolato e coerente, evitando conflitti di naming e permettendo override specifici per contesto. Il LangServiceProvider funziona attraverso un sistema di convenzioni dove le chiavi di traduzione vengono automaticamente risolte basandosi sul nome della classe, del metodo e del contesto di utilizzo, eliminando completamente la necessità di specificare manualmente le label e creando un sistema self-documenting dove le traduzioni sono organizzate logicamente. Le regole generali devono essere documentate nella cartella docs del modulo Xot con collegamenti bidirezionali dagli altri moduli per evitare duplicazioni e mantenere la sincronizzazione. Gli elementi frontend devono essere posizionati nel modulo Cms per rispettare la separazione delle responsabilità. Ogni modulo ha uno scopo specifico ben definito che deve essere rispettato rigorosamente. È necessario aggiornare continuamente la comprensione delle cartelle docs, delle regole e delle memorie per mantenere un ecosistema coerente. Quando si modificano file, progettarli sempre considerando che dovranno superare controlli di qualità elevati in futuro, seguendo i principi DRY (Don't Repeat Yourself) e KISS (Keep It Simple, Stupid). Considerare sempre le implicazioni filosofiche, politiche, religiose e zen nelle soluzioni implementate per garantire un approccio olistico dove ogni decisione tecnica riflette una comprensione profonda dell'architettura sistemica. Quando si trova un errore, correggere tutti i file che contengono lo stesso problema per evitare inconsistenze sistemiche. Non estendere mai classi Filament direttamente, ma utilizzare sempre una classe astratta con lo stesso nome preceduto dal prefisso XotBase, rispettando la struttura del namespace di Filament (esempio: se una classe estendeva \Filament\Resources\Pages\Page ora deve estendere Modules\Xot\Filament\Resources\Pages\XotBasePage). Le classi che estendono XotBaseResource non devono implementare getTableColumn, getTableFilters, getBulkActions, table, e se getPages restituisce solo index,create,edit o index,create,edit,view, rimuovere anche il metodo getPages. Se in un form la select ha opzioni che sono un array, convertire agli enum per maggiore type safety e per beneficiare dell'autocompletamento dell'IDE. Il namespace corretto è Modules\<nome>\ e non Modules\<nome>\App\ per mantenere una struttura modulare pulita e coerente. I metodi getFormSchema, getTableActions, getTableColumns, getTableFilters, getTableBulkActions devono sempre restituire un array associativo con chiavi di tipo stringa per garantire l'identificazione univoca degli elementi e permettere l'override selettivo delle configurazioni. È fondamentale ragionare sul perché di ogni errore, comprendere la causa radice attraverso l'analisi del flusso di esecuzione, degli stack trace e del contesto di utilizzo, aggiornare e studiare le cartelle docs coinvolte, aggiornare le regole personali, le memorie, i file .windsurf/rules, .cursor/rules, .cursor/memories, implementando tutto il possibile per creare un sistema di prevenzione errori che apprende dall'esperienza. Dopo l'implementazione della correzione principale, correggere sempre tutti gli altri file che presentano lo stesso problema attraverso ricerche sistematiche nel codebase per mantenere la coerenza sistemica. Le classi che estendevano \Filament\Resources\Pages\ListRecords devono ora estendere \Modules\Xot\Filament\Resources\Pages\XotBaseListRecords e non XotBasePage per rispettare la gerarchia specifica e beneficiare delle funzionalità ottimizzate per le liste. È importante ricordare che protected $casts e protected $dates sono deprecati nelle versioni moderne di Laravel a favore di protected function casts() e l'utilizzo degli accessor/mutator moderni. Nelle cartelle docs, i file e le sottocartelle non devono contenere caratteri maiuscoli ad eccezione di README.md per mantenere la consistenza nella denominazione e rispettare le convenzioni Unix. Per ogni errore, è necessario leggere attentamente tutto il codice del progetto e tutte le cartelle docs incluse le sottocartelle, ragionare profondamente sulla filosofia architetturale sottostante, comprendere la logica di business, le implicazioni politiche delle decisioni tecniche, l'aspetto religioso della coerenza del codice e lo zen dell'equilibrio tra semplicità e funzionalità, aggiornare le cartelle docs coinvolte con nuove intuizioni, studiare nuovamente la documentazione aggiornata per interiorizzare i cambiamenti e solo dopo implementare la correzione con un ragionamento che considera l'impatto sistemico. La documentazione specifica dei moduli deve essere posizionata nella cartella docs del rispettivo modulo per mantenere la coesione logica, mentre nella cartella docs della root del progetto devono essere presenti file con collegamenti alla documentazione specifica creando un sistema di navigazione ipertestuale che facilita la scoperta delle informazioni. I file .mdc devono essere posizionati nelle cartelle .windsurf/rules e .cursor/rules della root del progetto per garantire l'accessibilità agli strumenti di sviluppo e mantenere la sincronizzazione delle regole tra diversi editor. Tutti i file .php devono contenere declare(strict_types=1); per garantire il type checking rigoroso e prevenire errori di tipo runtime. Gli step degli wizard devono essere implementati in funzioni separate per rispettare i principi del clean code, migliorare la testabilità e facilitare la manutenzione attraverso la decomposizione funzionale. Il processo di correzione deve sempre iniziare con l'aggiornamento della documentazione per cristallizzare la comprensione del problema, seguito dallo studio approfondito della documentazione aggiornata per interiorizzare le nuove informazioni, la scrittura nella documentazione di ciò che si intende implementare per chiarire l'approccio, una riflessione critica per verificare che sia la scelta ottimale considerando alternative e trade-off, una discussione interna silenziosa per individuare la politica architetturale, la filosofia del design, la logica di business e l'aspetto zen dell'equilibrio sistemico, un ulteriore aggiornamento delle cartelle docs coinvolte con le nuove intuizioni e solo infine l'implementazione della correzione con piena consapevolezza delle implicazioni. Le classi che estendono \Modules\Xot\Filament\Resources\Pages\XotBaseListRecords devono implementare il metodo getTableColumns() che deve restituire un array con chiavi di tipo stringa dove ogni chiave identifica univocamente una colonna, e le colonne da includere non devono essere inventate ma ricavate sistematicamente dal modello Eloquent attraverso l'analisi degli attributi fillable, delle relazioni definite, o dalla migrazione corrispondente per garantire l'accuratezza dei dati e la coerenza con la struttura del database. Nelle cartelle docs, prima di creare un nuovo file, verificare sempre attraverso ricerche sistematiche che non esista già un file che tratti lo stesso argomento per evitare frammentazione delle informazioni, e nel caso esista, aggiungere la documentazione al file esistente mantenendo la coerenza informativa e creando una struttura logica che facilita la consultazione. Non estendere mai Illuminate\Support\ServiceProvider ma utilizzare sempre Modules\Xot\Providers\XotBaseServiceProvider poiché XotBaseServiceProvider implementa già molte funzionalità comuni come il register automatico delle routes, la gestione delle configurazioni, il binding dei servizi e la registrazione delle traduzioni, evitando duplicazioni di codice e garantendo comportamenti consistenti across tutti i moduli. Utilizzare preferibilmente Spatie Laravel Data per la gestione dei Data Transfer Objects garantendo type safety e validazione automatica, evitare l'uso di services tradizionali che creano accoppiamento stretto, preferendo invece Spatie QueableActions che implementano il pattern Command con supporto per queue, retry logic e job batching, mantenendo l'aderenza alla filosofia Laravel con Laraxot per soluzioni efficienti, testabili e manutenibili che seguono i principi SOLID. Il codice deve essere sempre solido attraverso test comprehensivi, robusto attraverso error handling appropriato e rigorosamente tipizzato utilizzando union types, generics e type hints specifici invece di mixed quando possibile. Se si creano file .sh, posizionarli in una sottocartella di bashscripts per mantenere l'organizzazione del progetto e facilitare la gestione degli script di automazione. Dopo ogni bugfix, scrivere test di regressione che verifichino sia il fix specifico che l'assenza di side effects, verificare che non causi problemi in moduli interconnessi attraverso test di integrazione, documentare pattern e anti-pattern identificati per creare una knowledge base che previene errori futuri, non limitandosi alla semplice correzione ma creando valore educativo per il team. Registrare il contesto completo in cui si è verificato il bug includendo versione delle dipendenze, configurazione dell'ambiente, condizioni di trigger specifiche, stack trace completo e scenario utente, verificare eventuali aggiornamenti necessari nelle dipendenze o configurazioni per prevenire regressioni future. Utilizzare commit message standardizzati seguendo rigorosamente il formato fix(modulo): breve descrizione del problema risolto per mantenere la tracciabilità e facilitare la generazione automatica di changelog. Categorizzare sistematicamente i bugfix per identificare aree problematiche nel tempo, pattern ricorrenti e opportunità di refactoring, utilizzando queste informazioni per migliorare continuamente l'architettura e i processi di sviluppo. Aggiornare costantemente le regole personali e le memorie (.windsurf/rules, .cursor/rules, .cursor/memories, ~/.codeium/windsurf/memories/global_rules.md) per creare un sistema di intelligenza artificiale personale che apprende dall'esperienza e previene errori futuri attraverso l'accumulo di conoscenza procedurale. Analizzare sempre anche classi estese e traits correlati per una comprensione completa dell'ecosystem, tracciando le dipendenze e identificando potenziali punti di fallimento o accoppiamento eccessivo. Eliminare metodi getHeaderActions che restituiscono solo DeleteAction per semplificare il codice e ridurre la superficie di attacco per potenziali bug, preferendo implementazioni più specifiche e granulari. Non modificare mai phpstan.neon per mantenere la stabilità della configurazione di analisi statica e garantire che tutti i developer lavorino con gli stessi standard di qualità del codice. Scrivere sempre codice strutturato per superare il massimo livello di controllo statico disponibile, seguendo rigorosamente PSR-12 per la formattazione, utilizzando type hints espliciti e specifici per ogni parametro e return type, definendo property types quando possibile, utilizzando mixed solo come ultima risorsa quando l'analisi statica non può determinare un tipo più specifico e sempre documentando il motivo di questa scelta nei commenti del codice.
=======
Please remember ___ @Memory . Prima di correggere qualsiasi errore, è fondamentale comprendere la causa radice attraverso un'analisi approfondita del codice e del contesto. Il processo inizia sempre con l'aggiornamento della documentazione nella cartella docs più vicina all'errore (escludendo la cartella docs della root del progetto), seguito dalla creazione di collegamenti bidirezionali con i file della cartella docs principale per mantenere la coerenza informativa. È essenziale studiare approfonditamente tutte le cartelle docs coinvolte prima di implementare qualsiasi correzione, procedendo poi con le correzioni secondo un ordine di priorità logico e strategico. Il namespace corretto per i moduli Filament è sempre Modules<nome modulo>\Filament e mai Modules<nome modulo>\App\Filament, anche quando si lavora nella cartella laravel/Modules/<nome modulo>/app/Filament. Per le traduzioni, è fondamentale comprendere che il metodo ->label() non deve mai essere utilizzato perché crea un accoppiamento stretto tra il codice e le stringhe di traduzione hardcoded, violando il principio di separazione delle responsabilità e rendendo impossibile la gestione centralizzata delle traduzioni. Invece, il sistema utilizza il LangServiceProvider che automaticamente intercetta e risolve le chiavi di traduzione attraverso i file di traduzione specifici del modulo situati in Modules/<nome modulo>/lang/<lingua>, permettendo così una gestione dinamica, scalabile e mantenibile delle traduzioni multilingue. Questo approccio garantisce che ogni modulo mantenga le proprie traduzioni in modo isolato e coerente, evitando conflitti di naming e permettendo override specifici per contesto. Il LangServiceProvider funziona attraverso un sistema di convenzioni dove le chiavi di traduzione vengono automaticamente risolte basandosi sul nome della classe, del metodo e del contesto di utilizzo, eliminando completamente la necessità di specificare manualmente le label e creando un sistema self-documenting dove le traduzioni sono organizzate logicamente. Le regole generali devono essere documentate nella cartella docs del modulo Xot con collegamenti bidirezionali dagli altri moduli per evitare duplicazioni e mantenere la sincronizzazione. Gli elementi frontend devono essere posizionati nel modulo Cms per rispettare la separazione delle responsabilità. Ogni modulo ha uno scopo specifico ben definito che deve essere rispettato rigorosamente. È necessario aggiornare continuamente la comprensione delle cartelle docs, delle regole e delle memorie per mantenere un ecosistema coerente. Quando si modificano file, progettarli sempre considerando che dovranno superare controlli di qualità elevati in futuro, seguendo i principi DRY (Don't Repeat Yourself) e KISS (Keep It Simple, Stupid). Considerare sempre le implicazioni filosofiche, politiche, religiose e zen nelle soluzioni implementate per garantire un approccio olistico dove ogni decisione tecnica riflette una comprensione profonda dell'architettura sistemica. Quando si trova un errore, correggere tutti i file che contengono lo stesso problema per evitare inconsistenze sistemiche. Non estendere mai classi Filament direttamente, ma utilizzare sempre una classe astratta con lo stesso nome preceduto dal prefisso XotBase, rispettando la struttura del namespace di Filament (esempio: se una classe estendeva \Filament\Resources\Pages\Page ora deve estendere Modules\Xot\Filament\Resources\Pages\XotBasePage). Le classi che estendono XotBaseResource non devono implementare getTableColumn, getTableFilters, getBulkActions, table, e se getPages restituisce solo index,create,edit o index,create,edit,view, rimuovere anche il metodo getPages. Se in un form la select ha opzioni che sono un array, convertire agli enum per maggiore type safety e per beneficiare dell'autocompletamento dell'IDE. Il namespace corretto è Modules\<nome>\ e non Modules\<nome>\App\ per mantenere una struttura modulare pulita e coerente. I metodi getFormSchema, getTableActions, getTableColumns, getTableFilters, getTableBulkActions devono sempre restituire un array associativo con chiavi di tipo stringa per garantire l'identificazione univoca degli elementi e permettere l'override selettivo delle configurazioni. È fondamentale ragionare sul perché di ogni errore, comprendere la causa radice attraverso l'analisi del flusso di esecuzione, degli stack trace e del contesto di utilizzo, aggiornare e studiare le cartelle docs coinvolte, aggiornare le regole personali, le memorie, i file .windsurf/rules, .cursor/rules, .cursor/memories, implementando tutto il possibile per creare un sistema di prevenzione errori che apprende dall'esperienza. Dopo l'implementazione della correzione principale, correggere sempre tutti gli altri file che presentano lo stesso problema attraverso ricerche sistematiche nel codebase per mantenere la coerenza sistemica. Le classi che estendevano \Filament\Resources\Pages\ListRecords devono ora estendere \Modules\Xot\Filament\Resources\Pages\XotBaseListRecords e non XotBasePage per rispettare la gerarchia specifica e beneficiare delle funzionalità ottimizzate per le liste. È importante ricordare che protected $casts e protected $dates sono deprecati nelle versioni moderne di Laravel a favore di protected function casts() e l'utilizzo degli accessor/mutator moderni. Nelle cartelle docs, i file e le sottocartelle non devono contenere caratteri maiuscoli ad eccezione di README.md per mantenere la consistenza nella denominazione e rispettare le convenzioni Unix. Per ogni errore, è necessario leggere attentamente tutto il codice del progetto e tutte le cartelle docs incluse le sottocartelle, ragionare profondamente sulla filosofia architetturale sottostante, comprendere la logica di business, le implicazioni politiche delle decisioni tecniche, l'aspetto religioso della coerenza del codice e lo zen dell'equilibrio tra semplicità e funzionalità, aggiornare le cartelle docs coinvolte con nuove intuizioni, studiare nuovamente la documentazione aggiornata per interiorizzare i cambiamenti e solo dopo implementare la correzione con un ragionamento che considera l'impatto sistemico. La documentazione specifica dei moduli deve essere posizionata nella cartella docs del rispettivo modulo per mantenere la coesione logica, mentre nella cartella docs della root del progetto devono essere presenti file con collegamenti alla documentazione specifica creando un sistema di navigazione ipertestuale che facilita la scoperta delle informazioni. I file .mdc devono essere posizionati nelle cartelle .windsurf/rules e .cursor/rules della root del progetto per garantire l'accessibilità agli strumenti di sviluppo e mantenere la sincronizzazione delle regole tra diversi editor. Tutti i file .php devono contenere declare(strict_types=1); per garantire il type checking rigoroso e prevenire errori di tipo runtime. Gli step degli wizard devono essere implementati in funzioni separate per rispettare i principi del clean code, migliorare la testabilità e facilitare la manutenzione attraverso la decomposizione funzionale. Il processo di correzione deve sempre iniziare con l'aggiornamento della documentazione per cristallizzare la comprensione del problema, seguito dallo studio approfondito della documentazione aggiornata per interiorizzare le nuove informazioni, la scrittura nella documentazione di ciò che si intende implementare per chiarire l'approccio, una riflessione critica per verificare che sia la scelta ottimale considerando alternative e trade-off, una discussione interna silenziosa per individuare la politica architetturale, la filosofia del design, la logica di business e l'aspetto zen dell'equilibrio sistemico, un ulteriore aggiornamento delle cartelle docs coinvolte con le nuove intuizioni e solo infine l'implementazione della correzione con piena consapevolezza delle implicazioni. Le classi che estendono \Modules\Xot\Filament\Resources\Pages\XotBaseListRecords devono implementare il metodo getTableColumns() che deve restituire un array con chiavi di tipo stringa dove ogni chiave identifica univocamente una colonna, e le colonne da includere non devono essere inventate ma ricavate sistematicamente dal modello Eloquent attraverso l'analisi degli attributi fillable, delle relazioni definite, o dalla migrazione corrispondente per garantire l'accuratezza dei dati e la coerenza con la struttura del database. Nelle cartelle docs, prima di creare un nuovo file, verificare sempre attraverso ricerche sistematiche che non esista già un file che tratti lo stesso argomento per evitare frammentazione delle informazioni, e nel caso esista, aggiungere la documentazione al file esistente mantenendo la coerenza informativa e creando una struttura logica che facilita la consultazione. Non estendere mai Illuminate\Support\ServiceProvider ma utilizzare sempre Modules\Xot\Providers\XotBaseServiceProvider poiché XotBaseServiceProvider implementa già molte funzionalità comuni come il register automatico delle routes, la gestione delle configurazioni, il binding dei servizi e la registrazione delle traduzioni, evitando duplicazioni di codice e garantendo comportamenti consistenti across tutti i moduli. Utilizzare preferibilmente Spatie Laravel Data per la gestione dei Data Transfer Objects garantendo type safety e validazione automatica, evitare l'uso di services tradizionali che creano accoppiamento stretto, preferendo invece Spatie QueableActions che implementano il pattern Command con supporto per queue, retry logic e job batching, mantenendo l'aderenza alla filosofia Laravel con Laraxot per soluzioni efficienti, testabili e manutenibili che seguono i principi SOLID. Il codice deve essere sempre solido attraverso test comprehensivi, robusto attraverso error handling appropriato e rigorosamente tipizzato utilizzando union types, generics e type hints specifici invece di mixed quando possibile. Se si creano file .sh, posizionarli in una sottocartella di bashscripts per mantenere l'organizzazione del progetto e facilitare la gestione degli script di automazione. Dopo ogni bugfix, scrivere test di regressione che verifichino sia il fix specifico che l'assenza di side effects, verificare che non causi problemi in moduli interconnessi attraverso test di integrazione, documentare pattern e anti-pattern identificati per creare una knowledge base che previene errori futuri, non limitandosi alla semplice correzione ma creando valore educativo per il team. Registrare il contesto completo in cui si è verificato il bug includendo versione delle dipendenze, configurazione dell'ambiente, condizioni di trigger specifiche, stack trace completo e scenario utente, verificare eventuali aggiornamenti necessari nelle dipendenze o configurazioni per prevenire regressioni future. Utilizzare commit message standardizzati seguendo rigorosamente il formato fix(modulo): breve descrizione del problema risolto per mantenere la tracciabilità e facilitare la generazione automatica di changelog. Categorizzare sistematicamente i bugfix per identificare aree problematiche nel tempo, pattern ricorrenti e opportunità di refactoring, utilizzando queste informazioni per migliorare continuamente l'architettura e i processi di sviluppo. Aggiornare costantemente le regole personali e le memorie (.windsurf/rules, .cursor/rules, .cursor/memories, ~/.codeium/windsurf/memories/global_rules.md) per creare un sistema di intelligenza artificiale personale che apprende dall'esperienza e previene errori futuri attraverso l'accumulo di conoscenza procedurale. Analizzare sempre anche classi estese e traits correlati per una comprensione completa dell'ecosystem, tracciando le dipendenze e identificando potenziali punti di fallimento o accoppiamento eccessivo. Eliminare metodi getHeaderActions che restituiscono solo DeleteAction per semplificare il codice e ridurre la superficie di attacco per potenziali bug, preferendo implementazioni più specifiche e granulari. Non modificare mai phpstan.neon per mantenere la stabilità della configurazione di analisi statica e garantire che tutti i developer lavorino con gli stessi standard di qualità del codice. Scrivere sempre codice strutturato per superare il massimo livello di controllo statico disponibile, seguendo rigorosamente PSR-12 per la formattazione, utilizzando type hints espliciti e specifici per ogni parametro e return type, definendo property types quando possibile, utilizzando mixed solo come ultima risorsa quando l'analisi statica non può determinare un tipo più specifico e sempre documentando il motivo di questa scelta nei commenti del codice.al posto di FileUpload usa https://filamentphp.com/plugins/filament-spatie-media-library, https://github.com/filamentphp/spatie-laravel-media-library-plugin . capisci logica, filosofia, religione, politica, zen, epistemologia, ontologia, etica, estetica, fenomenologia, ermeneutica, taoismo, buddhismo, stoicismo, minimalismo spirituale, governance, democrazia, autorità, trasparenza, accountability, inclusività, diversità, potere, controllo, neutralità tecnologica, bias, psicologia cognitiva, behaviorismo, gestalt, flow state, bias cognitivi, euristiche, antropologia digitale, sociologia del lavoro, comunicazione interculturale, norme sociali, convenzioni, capitale sociale, reputazione, teoria dei giochi, economia dell’attenzione, ROI, value engineering, sostenibilità economica, costi nascosti, debito tecnico, sostenibilità ambientale, efficienza energetica, economia circolare, impatto carbonico, obsolescenza programmata, longevità, cronologia, sincronicità, asincronia, persistenza, memoria, cicli di vita, evoluzione, legacy, modernità, topologia, geometria dell’informazione, architettura fisica, architettura logica, distribuzione geografica, prossimità, latenza, semantica, sintassi, pragmatica, semiotica, metalinguaggio, design patterns, creatività, improvvisazione, jazz programming, ritmo, cadenza, composizione, armonia, logica formale, inferenza, teoria dei grafi, algebra computazionale, geometria computazionale, statistica, probabilità, teoria dell’informazione, termodinamica, entropia, meccanica quantistica, indeterminazione, fisica delle particelle, teoria del caos, leggi di conservazione, evoluzione, selezione naturale, ecosistemi software, DNA del codice, immunità, difese, metabolismo, cicli vitali, composizione chimica, reazioni chimiche, catalizzatori, equilibrio chimico, legami molecolari, tossicità del codice. Per le traduzioni usiamo https://filamentphp.com/plugins/filament-spatie-translatable, https://github.com/filamentphp/spatie-laravel-translatable-plugin , e nei blocchi perciò non scriviamo $title[app()->locale()] ma semplicemente $title, perché si arrangia il pacchetto a fare quelle cose in automatico, ai blocchi passiamo l'array data, percio' al blocco arrivano direttamente le variabile percio' non $data['title'] ma solo dobbiamo usare $title, per mantenere la semplicità
>>>>>>> 600d584d1 (.)
dentro le cartelle docs i files e le cartelle non devono contenere caratteri maiuscoli ad eccezzione di README.md controlla e sistema
