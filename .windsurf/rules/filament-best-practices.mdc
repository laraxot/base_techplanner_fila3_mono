---
description:
globs:
alwaysApply: true
---
# Filament Best Practices for

## Overview
Best practices for using Filament in modular Laravel projects, specifically tailored for the  project.

# Filament Best Practices for

## Overview
Best practices for using Filament in modular Laravel projects, specifically tailored for the  project.

# Filament Best Practices for

## Overview
Best practices for using Filament in modular Laravel projects, specifically tailored for the  project.

# Filament Best Practices for

## Overview
Best practices for using Filament in modular Laravel projects, specifically tailored for the  project.

## Rules

### Extending Filament Classes
- **DO NOT** extend Filament classes directly. Always create custom wrappers.
- Use traits for reusable functionality.
- Follow the composition over inheritance pattern.
- Maintain compatibility with Filament updates.
- Centralize common configurations in base classes.
- Do not add custom static properties to resources (e.g., `$navigationIcon`, `$navigationGroup`, `$translationPrefix`).
- Never use the `->label()` method directly in forms; use translation files instead.

### Resource Guidelines
- Remove `getRelations()` if it returns an empty array.
- Remove `getPages()` if it contains only standard routes.
- `getFormSchema()` must return an associative array with string keys.

### List Records Guidelines
- Remove `Actions()` if it returns only `createAction`.
- `getListTableColumns()` must return an associative array with string keys.

### Translation Rules
- **NEVER** use the `->label()` method in Filament components.
- Labels are managed automatically by the translation system.
- Use the expanded structure for fields in translation files.
- Follow the naming convention for translation keys: `module::resource.fields.field.label`.

###  Specific Guidelines

When creating Filament resources, adhere to the following conventions to maintain consistency with the project's architecture:

```php
// ❌ DO NOT
use Filament\Resources\Resource;

class DoctorResource extends Resource
{
    public function form(Form $form)
    {
        return $form->schema([...]);
    }
}

// ✅ DO
use Modules\Xot\Filament\Resources\XotBaseResource;

class DoctorResource extends XotBaseResource
{
    public function form(Form $form)
    {
        return $form->schema([...]);
    }
}
```

#### Best Practices for Resources
1. **NEVER** extend `Filament\Resources\Resource` directly.
2. **ALWAYS** extend `Modules\Xot\Filament\Resources\XotBaseResource`.
3. Utilize the base implementations provided by Xot.
4. Maintain consistency with the rest of the system.
5. Leverage the default functionalities of `XotBaseResource`.

#### What NOT to Implement in XotBaseResource

Avoid redefining properties or methods that are already managed by `XotBaseResource`:

```php
// ❌ DO NOT - These are already handled by XotBaseResource
class DoctorResource extends XotBaseResource
{
    // ❌ ERROR: Do not define these properties when extending XotBaseResource
    protected static ?string $navigationIcon = 'heroicon-o-user';  // NOT NECESSARY
    protected static ?string $navigationGroup = 'Gestione';        // NOT NECESSARY
    protected static ?int $navigationSort = 1;                     // NOT NECESSARY

    // ❌ ERROR: Use getListTableColumns() instead of getTableColumns()
    public static function getTableColumns(): array                // NOT NECESSARY
    {
        return [...];
    }

    public static function getRelations(): array                   // NOT NECESSARY
    {
        return [...];
    }

    public static function getPages(): array                       // NOT NECESSARY if using only index, create, edit
    {
        return [
            'index' => Pages\ListDoctors::route('/'),
            'create' => Pages\CreateDoctor::route('/create'),
            'edit' => Pages\EditDoctor::route('/{record}/edit'),
        ];
    }
}

// ✅ DO - Implement only module-specific elements
class DoctorResource extends XotBaseResource
{
    public function form(Form $form): Form
    {
        return $form->schema([
            // Module-specific schema
        ]);
    }

    // Implement getPages() ONLY if adding custom pages beyond index, create, edit
    public static function getPages(): array
    {
        return [
            'index' => Pages\ListDoctors::route('/'),
            'create' => Pages\CreateDoctor::route('/create'),
            'edit' => Pages\EditDoctor::route('/{record}/edit'),
            'custom' => Pages\CustomDoctor::route('/custom'),  // Only if a custom page is needed
        ];
    }
}
```

## Additional Guidelines
- Ensure that all Filament resources follow the project's coding standards (PSR-12).
- Use type hints and return type declarations for methods in Filament resources.
- Document custom methods or complex logic within Filament resources for clarity.

## Example
```php
// Correct implementation of a Filament Resource
class MyResource extends XotBaseResource
{
    public static function getFormSchema(): array
    {
        return [
            'title' => Forms\Components\TextInput::make('title'),
            'content' => Forms\Components\RichEditor::make('content'),
        ];
    }
}
```

## Troubleshooting
- If a static property override error occurs, remove the property from the resource and centralize it in the base class.
- If translations are not applied, check the structure of the lang files and the absence of hardcoded `->label()`.

## Related Rules
- [Filament Resources](mdc:filament-resources.mdc)
- [Filament Components](mdc:filament-components.mdc)
- [Translation System](mdc:translation-system-rules.mdc)
- [Filament Docs](mdc:https:/filamentphp.com/docs)
- [Best practices for reusable modules](mdc:module-documentation-neutrality.mdc)
- [Model inheritance best practices](mdc:model-inheritance-best-practices.mdc)

# Regola: Path View Widget Filament e Localizzazione

- Tutti i widget Filament devono avere la view in `modulo::filament.widgets.nome-widget`.
- Non usare mai `modulo::widgets.nome-widget` o altri path non standard.
- Non usare mai ->label(), ->placeholder(), __() o trans() nei form component (TextInput, Select, ecc).
- La localizzazione è centralizzata tramite LangServiceProvider e i file di lingua del modulo.
- Le chiavi dei campi devono corrispondere a quelle dei file di lingua.

## Esempio corretto
```php
protected static string $view = '<nome progetto>::filament.widgets.find-doctor-and-appointment';
TextInput::make('location')->required()
```

## Esempio errato
```php
protected static string $view = '<nome progetto>::widgets.find-doctor-and-appointment';
TextInput::make('location')->label(__('modulo::campo.label'))
```

**Motivazione:** coerenza, manutenzione, override, policy di qualità.

> Aggiornare sempre anche i file .mdc in .cursor/rules

# Regola: Ereditarietà e Trait nei Widget Filament

- Non replicare mai trait, interfacce o logica già presenti nella classe base che si estende (es. XotBaseWidget).
- Studiare sempre la classe base prima di estendere.
- Se serve estendere il comportamento, usare override o metodi custom, non duplicare trait/interfacce.

## Esempio errato
```php
class FindDoctorAndAppointmentWidget extends XotBaseWidget implements HasForms
{
    use InteractsWithForms; // ERRORE: già presente in XotBaseWidget
}
```

## Esempio corretto
```php
class FindDoctorAndAppointmentWidget extends XotBaseWidget
{
    // NIENTE implements HasForms, NIENTE use InteractsWithForms
}
```

**Motivazione:** DRY, KISS, manutenzione, coerenza, evitare conflitti e ridondanza.

> Aggiornare sempre anche i file .mdc in .cursor/rules

> [2025-05-28] Policy aggiornata: tutte le pagine di form devono includere direttamente solo widget Filament modulari, mai form custom. Motivazione: coerenza architetturale, manutenzione, DRY, troubleshooting semplificato.

## Livewire e Filament: inclusione obbligatoria di @livewireStyles e @livewireScripts
Per evitare errori 419 Page Expired nei widget Filament/Livewire, il layout DEVE includere @livewireStyles subito dopo @filamentStyles e @livewireScripts subito dopo @filamentScripts. Vedi anche docs/widget-deleting-method-error.md.

## View widget: solo wrapper per $this->form
Le view dei widget Filament devono essere solo wrapper per $this->form. Niente markup custom, niente logica Livewire/AlpineJS, niente gestione CSRF manuale. Tutta la logica va nel widget PHP o nel tema. Motivazione: coerenza, DRY, KISS, troubleshooting semplificato. Collegamento a docs/xot.md.

## Vietato ->label() e ->placeholder() nei form component
Tutti i form component devono usare solo chiavi campo, senza label o placeholder inline. Le etichette e i placeholder sono gestiti tramite i file di traduzione del modulo e il LangServiceProvider. Motivazione: coerenza, centralizzazione, override semplice, policy di qualità. Collegamento a docs/xot.md.

## Regola: trait solo se riusabili
I trait vanno creati solo se riutilizzati in più classi. Vietato creare trait per una sola classe. Se la logica è specifica di un solo modello, va implementata direttamente nella classe. Motivazione: semplicità, KISS, manutenibilità, evitare complessità inutile. Collegamento a docs/xot.md.

## Policy di naming enum
Il nome della classe enum DEVE sempre corrispondere al nome del file (es. UserTypeEnum.php -> enum UserTypeEnum: string ...). Aggiornare sempre sia il nome del file che il nome della classe. Motivazione: coerenza, autoloading, refactoring semplice. Collegamento a docs/xot.md e docs/enum-naming-policy.md.

## Regola Obbligatoria: getTableColumns nelle ListRecords

- Tutte le pagine che estendono XotBaseListRecords DEVONO implementare il metodo getTableColumns().
- Il metodo deve restituire un array associativo con chiavi stringa (nome campo).
- Le colonne vanno ricavate dal modello e dalla migrazione, senza inventare campi.
- Le etichette sono gestite solo tramite i file di traduzione del modulo (mai ->label()).
- Motivazione: coerenza, automazione, DRY, compatibilità con TableLayoutEnum e HasXotTable.
- Aggiornare sempre anche questa regola nei file .mdc locali.

## Regola: Relazioni molti-a-molti tra entità

- Se due entità possono essere collegate in modo simmetrico (es. uno studio ha molti dottori e un dottore può lavorare in più studi), usare sempre belongsToManyX.
- La tabella pivot deve essere gestita in modo centralizzato e documentata.
- Motivazione filosofica: massima flessibilità, nessun lock-in, simmetria tra le entità.
- Politica: ogni modulo può estendere la relazione senza vincoli.
- Zen: la relazione è fluida, ogni entità può collaborare con più controparti.
- I RelationManager devono usare la relazione belongsToManyX e la chiave corretta.
- Aggiornare sempre la documentazione locale e globale.

## Regola: Vietato duplicare trait già presenti nella catena di ereditarietà

- I trait (es. SoftDeletes, BelongsToTenant, RelationX, HasFactory, Notifiable, ecc.) vanno dichiarati **solo** nella classe base o dove servono per la prima volta.
- Vietato ridichiararli nei modelli figli (es. Doctor, Patient) se già presenti in User/BaseUser.
- Motivazione filosofica: centralizzazione, DRY, nessun lock-in, serenità del codice.
- Politica: evitare conflitti, warning, override indesiderati.
- Zen: un solo punto di verità, codice pulito e manutenibile.

**Esempio corretto:**
```php
class Doctor extends User {
    use HasParent;
    // NIENTE altri trait già ereditati
}
```

**Esempio errato:**
```php
class Doctor extends User {
    use HasParent, SoftDeletes, BelongsToTenant, RelationX; // ❌ ERRORE
}
```

Aggiornare sempre la documentazione locale e globale se si modifica la catena di ereditarietà.

## Regola: Modello pivot custom per relazioni molti-a-molti con dati aggiuntivi

- Se una relazione molti-a-molti richiede dati aggiuntivi (es. orari, flag, policy), usare sempre un modello pivot custom (es. DoctorStudio).
- La tabella pivot deve avere chiave primaria composta e campi aggiuntivi documentati.
- Motivazione filosofica: la relazione è un'entità a sé, non solo un legame.
- Politica: audit trail, policy multi-tenant, massima estendibilità.
- Zen: la relazione è fluida, ma tracciabile e arricchita di significato.
- Aggiornare sempre la documentazione locale e globale se si aggiungono/modificano campi o logiche nella tabella pivot.

**Nota importante:**
La logica di `belongsToManyX` centralizza automaticamente la gestione del modello pivot, dei campi extra e delle policy multi-tenant. **Non va mai** aggiunto chaining come `->using()`, `->withPivot()`, `->withTimestamps()`: è tutto gestito dal trait.

**Motivazione:** DRY, nessun lock-in, un solo punto di verità, coerenza con la filosofia Xot.

**Esempio:**
```php
public function studios(): BelongsToMany
{
    return $this->belongsToManyX(Studio::class);
}
```

## Regola: Chiavi esterne nelle tabelle pivot

- Usare sempre `$table->foreignIdFor(Modello::class)` per le chiavi esterne nelle tabelle pivot (es. doctor_id, studio_id).
- Non usare mai `$table->uuid()` o `$table->integer()` manuale: si perde type safety, coerenza e integrazione con Eloquent.
- Motivazione: coerenza, type safety, DRY, migliore integrazione con Eloquent, nessun lock-in.
- Filosofia: un solo punto di verità, nessuna duplicazione, rispetto della struttura modulare.
- Politica: audit trail, policy multi-tenant, massima estendibilità.
- Zen: serenità del codice, nessun errore di mapping, refactoring sicuro.

**Esempio corretto:**
```php
$table->foreignIdFor(\Modules\<nome progetto>\Models\Doctor::class)
    ->comment('ID del dottore (riferimento alla tabella users)');
$table->foreignIdFor(\Modules\<nome progetto>\Models\Studio::class)
    ->comment('ID dello studio (riferimento alla tabella studios)');
```

## Regola: Niente metodo down() nelle migration che estendono XotBaseMigration

- Chi estende `XotBaseMigration` **non deve mai** dichiarare il metodo `down()`.
- La gestione del rollback è centralizzata e automatica nella base Xot, per evitare duplicazione, errori e conflitti.
- Motivazione: DRY, coerenza, nessun lock-in, manutenzione semplificata.
- Filosofia: un solo punto di verità, nessuna duplicazione, serenità del codice.
- Politica: rollback sicuro, refactoring semplice, policy multi-tenant.
- Zen: codice pulito, nessun errore di override.

**Esempio corretto:**
```php
return new class() extends XotBaseMigration {
    public function up(): void
    {
        $this->tableCreate(function (Blueprint $table): void {
            // ...
        });
    }
    // NIENTE metodo down()
};
```

## Regola: Timestamp e soft delete nelle migration XotBaseMigration

- Per aggiungere timestamp e soft delete, usare **solo** `$this->updateTimestamps($table, true)` dentro il blocco `tableUpdate`.
- Non usare mai `$table->timestamps()` direttamente: si rischia di perdere coerenza, duplicare logica e rompere la policy di centralizzazione Xot.
- Motivazione: DRY, coerenza, nessun lock-in, manutenzione semplificata.
- Filosofia: un solo punto di verità, nessuna duplicazione, serenità del codice.
- Politica: gestione centralizzata, refactoring semplice, policy multi-tenant.
- Zen: codice pulito, nessun errore di override.

**Esempio corretto:**
```php
$this->tableUpdate(function (Blueprint $table): void {
    $this->updateTimestamps($table, true);
});
```

## Regola: Pivot custom devono estendere BasePivot e niente protected $table

- I pivot custom (es. DoctorStudio) devono **sempre** estendere BasePivot.
- Non dichiarare mai `protected $table`: la gestione della tabella è centralizzata e automatica secondo la filosofia Xot.
- Motivazione: type safety, DRY, coerenza, nessun lock-in, serenità del codice.
- Filosofia: un solo punto di verità, nessuna duplicazione, rispetto della struttura modulare.
- Politica: gestione centralizzata, refactoring semplice, policy multi-tenant.
- Zen: codice pulito, nessun errore di mapping o override.

**Esempio corretto:**
```php
class DoctorStudio extends BasePivot
{
    // NIENTE protected $table
    // ...
}
```

## [AGGIORNAMENTO 2024-06-XX] - Disponibilità solo su appointments
- Le disponibilità dei dottori vanno gestite solo tramite la tabella appointments (con patient_id null o type AVAILABILITY).
- Vietato creare tabelle o modelli separati (es. doctor_availabilities) per le disponibilità.
- Tutto il calendario lavora su appointments, distinguendo tra disponibilità e appuntamenti tramite i campi esistenti.
- Motivazione: un solo punto di verità, DRY, KISS, nessun lock-in, serenità del codice, nessuna duplicazione, massima compatibilità con FullCalendar e Filament.
- Checklist: vedi docs/appointment-management.md, docs/calendar/doctor-availability-management.md, docs/fullcalendar_parental_widgets.md, docs/calendar/widgets/doctor-calendar-widget.md
