---
description:
globs:
alwaysApply: false
---
# Regola Windsurf - RadioCardSelector Pattern

## Ambito
- Globale (tutti i moduli che necessitano selezioni card-based)
- Componenti Filament Form riutilizzabili
- Pattern per widget multi-step con selezioni visuali

## Motivazione Critica
- Evitare implementazioni spaghetti con View custom complesse
- Garantire componenti Filament Form nativi e riutilizzabili
- Prevenire duplicazione di logica selezione card
- Assicurare pattern consistenti cross-module

## Regole Obbligatorie

### 1. Componente Base UI
```php
// ✅ SEMPRE utilizzare RadioCardSelector per selezioni card
use Modules\UI\Forms\Components\RadioCardSelector;

// Pattern corretto per selezioni visuali
RadioCardSelector::make('field_name')
    ->sectionTitle(__('module::section.title'))
    ->sectionSubtitle(__('module::section.subtitle'))
    ->cards(fn (Get $get) => $this->getDataCards($get))
    ->populatesField('field_name_display')
    ->emptyStateTitle(__('module::empty.title'))
    ->emptyStateDescription(__('module::empty.description'))
    ->required()
    ->columnSpanFull()
```

### 2. Struttura Dati Cards
```php
// ✅ SEMPRE utilizzare questa struttura per le card
private function getDataCards(Get $get): array
{
    $entities = $this->getFilteredEntities($get);
    
    return $entities->map(function ($entity) {
        return [
            'id' => $entity->id,                    // Required: ID univoco
            'title' => $entity->name,               // Required: Titolo principale
            'subtitle' => $entity->address,         // Optional: Sottotitolo/indirizzo
            'description' => $entity->description,  // Optional: Descrizione dettagliata
            'meta' => $entity->phone,              // Optional: Info meta (telefono, email)
            'extra' => $entity->doctors->count() . ' disponibili', // Optional: Info extra
        ];
    })->toArray();
}
```

### 3. Campo Popolato Automaticamente
```php
// ✅ SEMPRE utilizzare TextInput readonly per mostrare selezione
Form\TextInput::make('selected_entity_name')
    ->label(__('module::fields.selected_entity.label'))
    ->placeholder(__('module::fields.selected_entity.placeholder'))
    ->readonly()
    ->required()
```

### 4. Traduzioni Strutturate
```php
// ✅ SEMPRE utilizzare traduzioni strutturate complete
return [
    'section' => [
        'title' => 'Titolo Sezione',
        'subtitle' => 'Sottotitolo esplicativo',
    ],
    'empty' => [
        'title' => 'Nessun elemento trovato',
        'description' => 'Descrizione stato vuoto con suggerimenti',
    ],
    'fields' => [
        'selected_entity' => [
            'label' => 'Elemento Selezionato',
            'placeholder' => 'Nessuna selezione',
            'helper_text' => 'Clicca su una card per selezionare',
        ],
    ],
];
```

## Anti-Pattern da Evitare

### ❌ View Custom Complesse
```php
// ❌ NON fare mai questo
Form\View::make('module::custom-complex-selector')
    ->viewData(['complex' => 'data']);
```

### ❌ Alpine.js Spaghetti
```php
// ❌ NON implementare logica complessa in View
<div x-data="{ /* logica complessa */ }">
    <!-- Alpine.js complesso con business logic -->
</div>
```

### ❌ Componenti Non Riutilizzabili
```php
// ❌ NON creare componenti specifici non riutilizzabili
class StudioOnlySelector extends Component {
    // Componente troppo specifico
}
```

### ❌ Hardcoded Business Logic in View
```php
// ❌ NON mettere business logic nelle view
@php
    $studios = Studio::where('active', true)->get();
@endphp
```

## Best Practice

### 1. Separazione Responsabilità
- **RadioCardSelector**: UI logic e interazioni
- **getDataCards()**: Business logic e data transformation
- **Traduzioni**: Localizzazione separata
- **Styling**: Design system coerente

### 2. Performance
- Utilizzare closure `fn (Get $get)` per lazy loading
- Limitare risultati a <100 elementi per performance
- Implementare caching quando appropriato

### 3. Accessibilità
- Keyboard navigation automatica
- Screen reader support integrato
- Visual feedback chiaro per selezioni
- Color contrast WCAG 2.1 compliant

### 4. Testing
- Componente isolato facilmente testabile
- Mock delle closure per unit test
- Test di integrazione per widget completi

## Esempi Cross-Module

### Healthcare (SaluteOra)
```php
RadioCardSelector::make('studio_id')
    ->cards(fn (Get $get) => $this->getStudioCards($get))
    ->sectionTitle(__('techplanner::studio_selector.title'))
```

### E-commerce
```php
RadioCardSelector::make('product_id')
    ->cards(fn (Get $get) => $this->getProductCards($get))
    ->sectionTitle(__('shop::product_selector.title'))
```

### Real Estate
```php
RadioCardSelector::make('property_id')
    ->cards(fn (Get $get) => $this->getPropertyCards($get))
    ->sectionTitle(__('realestate::property_selector.title'))
```

## Checklist Implementazione

- [ ] Estende RadioCardSelector (non View custom)
- [ ] Struttura card standardizzata con ID richiesto
- [ ] Closure per lazy loading dati
- [ ] Campo popolato automaticamente readonly
- [ ] Traduzioni complete strutturate
- [ ] Empty states gestiti
- [ ] Performance <100ms per <50 elementi
- [ ] Documentazione aggiornata

## Collegamenti

- [RadioCardSelector Implementation](../../Modules/UI/docs/components/radio-card-selector-component.md)
- [FindDoctorAndAppointment Widget](../../Modules/SaluteOra/docs/widgets/radio-card-implementation-completed.md)
- [UI Components Overview](../../Modules/UI/docs/readme.md)

## Ultimo aggiornamento
Gennaio 2025 - Pattern consolidato e production-ready
