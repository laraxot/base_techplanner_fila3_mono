---
description: Pattern e best practice per l'utilizzo di Spatie Laravel Data in progetti Laraxot/<nome progetto>
globs: ["**/Data/**/*.php", "**/Services/**/*.php"]
alwaysApply: true
---

# Pattern per Spatie Laravel Data in Laraxot/<nome progetto>

## Principi Fondamentali

- **Preferenza**: Utilizzare SEMPRE Spatie Laravel Data invece di array non tipizzati
- **Tipizzazione**: Dichiarare SEMPRE tipi espliciti per proprietà, parametri e valori di ritorno
- **Immutabilità**: Preferire oggetti immutabili con costruttori ben definiti
- **Namespace**: Rispettare lo schema `Modules\{ModuleName}\Data`
- **Documentazione**: Documentare tutte le classi Data nel modulo corrispondente

## Pattern Spatie Laravel Data

### ✅ Pattern Corretto - Data Object Base

```php
<?php

declare(strict_types=1);

namespace Modules\ModuleName\Data;

use Spatie\LaravelData\Data;
use Spatie\LaravelData\Attributes\Validation\Required;
use Spatie\LaravelData\Attributes\Validation\StringType;
use Spatie\LaravelData\Attributes\WithCast;
use Spatie\LaravelData\Casts\DateTimeInterfaceCast;

class UserData extends Data
{
    public function __construct(
        #[Required, StringType]
        public readonly string $name,

        #[Required, StringType]
        public readonly string $email,

        #[WithCast(DateTimeInterfaceCast::class)]
        public readonly ?\DateTimeInterface $created_at = null,

        #[WithCast(DateTimeInterfaceCast::class)]
        public readonly ?\DateTimeInterface $updated_at = null,

        public readonly ?int $id = null,
    ) {
    }

    /**
     * Crea un nuovo UserData da un modello User.
     *
     * @param \Modules\ModuleName\Models\User $user
     * @return self
     */
    public static function fromModel(\Modules\ModuleName\Models\User $user): self
    {
        return new self(
            name: $user->name,
            email: $user->email,
            created_at: $user->created_at,
            updated_at: $user->updated_at,
            id: $user->id,
        );
    }

    /**
     * Crea un'istanza del modello User da questo Data Object.
     *
     * @return \Modules\ModuleName\Models\User
     */
    public function toModel(): \Modules\ModuleName\Models\User
    {
        $user = $this->id
            ? \Modules\ModuleName\Models\User::findOrFail($this->id)
            : new \Modules\ModuleName\Models\User();

        $user->name = $this->name;
        $user->email = $this->email;

        return $user;
    }
}
```

### ✅ Pattern Corretto - Data Object con Validazione

```php
<?php

declare(strict_types=1);

namespace Modules\ModuleName\Data;

use Spatie\LaravelData\Data;
use Spatie\LaravelData\Attributes\Validation\Required;
use Spatie\LaravelData\Attributes\Validation\StringType;
use Spatie\LaravelData\Attributes\Validation\Email;
use Spatie\LaravelData\Attributes\Validation\Min;
use Spatie\LaravelData\Attributes\Validation\Max;
use Spatie\LaravelData\Attributes\Validation\Numeric;

class ProductData extends Data
{
    public function __construct(
        #[Required, StringType, Min(3), Max(255)]
        public readonly string $name,

        #[Required, StringType]
        public readonly string $description,

        #[Required, Numeric, Min(0)]
        public readonly float $price,

        #[Required, Numeric, Min(0)]
        public readonly int $quantity,

        public readonly ?int $id = null,
    ) {
    }

    /**
     * Definisce regole di validazione addizionali.
     *
     * @return array<string, array<int, string>>
     */
    public static function rules(): array
    {
        return [
            'name' => ['unique:products,name'],
        ];
    }

    /**
     * Definisce messaggi di errore personalizzati.
     *
     * @return array<string, string>
     */
    public static function messages(): array
    {
        return [
            'name.unique' => __('modulename::validation.product.name.unique'),
        ];
    }
}
```

### ✅ Pattern Corretto - DTO Collection

```php
<?php

declare(strict_types=1);

namespace Modules\ModuleName\Data;

use Illuminate\Support\Collection;
use Spatie\LaravelData\DataCollection;

class UserDataCollection extends DataCollection
{
    public function __construct(
        public Collection|array $items
    ) {
        parent::__construct($items);
    }

    /**
     * Crea una collezione da un elenco di modelli.
     *
     * @param \Illuminate\Database\Eloquent\Collection<int, \Modules\ModuleName\Models\User> $users
     * @return self
     */
    public static function fromModels($users): self
    {
        return new self(
            $users->map(fn ($user) => UserData::fromModel($user))->all()
        );
    }

    /**
     * Restituisce il tipo di dato nella collezione.
     *
     * @return class-string
     */
    public static function getDataClass(): string
    {
        return UserData::class;
    }
}
```

### ✅ Pattern Corretto - Data Object con Relazioni

```php
<?php

declare(strict_types=1);

namespace Modules\ModuleName\Data;

use Spatie\LaravelData\Data;
use Spatie\LaravelData\Attributes\DataCollectionOf;
use Spatie\LaravelData\DataCollection;

class OrderData extends Data
{
    public function __construct(
        public readonly string $order_number,
        public readonly float $total_amount,
        public readonly string $status,
        #[DataCollectionOf(OrderItemData::class)]
        public readonly ?DataCollection $items = null,
        public readonly ?UserData $user = null,
        public readonly ?int $id = null,
    ) {
    }

    /**
     * Crea un OrderData da un modello Order con relazioni.
     *
     * @param \Modules\ModuleName\Models\Order $order
     * @return self
     */
    public static function fromModel(\Modules\ModuleName\Models\Order $order): self
    {
        // Carica relazioni se non già caricate
        if (!$order->relationLoaded('items')) {
            $order->load('items');
        }

        if (!$order->relationLoaded('user')) {
            $order->load('user');
        }

        return new self(
            order_number: $order->order_number,
            total_amount: $order->total_amount,
            status: $order->status,
            items: $order->items ? OrderItemData::collection($order->items) : null,
            user: $order->user ? UserData::from($order->user) : null,
            id: $order->id,
        );
    }
}
```

### ✅ Pattern Corretto - Enum Value Object

```php
<?php

declare(strict_types=1);

namespace Modules\ModuleName\Enums;

use Spatie\Enum\Laravel\Enum;

/**
 * @method static self draft()
 * @method static self published()
 * @method static self archived()
 */
final class StatusEnum extends Enum
{
    /**
     * Restituisce un array di etichette tradotte per le opzioni di enum.
     *
     * @return array<string, string>
     */
    public static function toSelectArray(): array
    {
        return [
            'draft' => __('modulename::enums.status.draft'),
            'published' => __('modulename::enums.status.published'),
            'archived' => __('modulename::enums.status.archived'),
        ];
    }

    /**
     * Determina se lo stato è considerato attivo.
     */
    public function isActive(): bool
    {
        return $this->value === self::published()->value;
    }
}
```

## Integrazione con Filament

### ✅ Pattern Corretto - Form e Data in Filament

```php
<?php

declare(strict_types=1);

namespace Modules\ModuleName\Filament\Resources;

use Filament\Resources\Resource;
use Filament\Resources\Form;
use Filament\Resources\Table;
use Filament\Forms;
use Filament\Tables;
use Modules\ModuleName\Data\UserData;
use Modules\ModuleName\Models\User;

class UserResource extends Resource
{
    protected static ?string $model = User::class;

    /**
     * Form schema per Filament.
     *
     * @param \Filament\Forms\Form $form
     * @return \Filament\Forms\Form
     */
    public static function form(Form $form): Form
    {
        return $form
            ->schema([
                Forms\Components\TextInput::make('name')
                    ->label(__('modulename::fields.name.label'))
                    ->placeholder(__('modulename::fields.name.placeholder'))
                    ->required()
                    ->maxLength(255),

                Forms\Components\TextInput::make('email')
                    ->label(__('modulename::fields.email.label'))
                    ->placeholder(__('modulename::fields.email.placeholder'))
                    ->email()
                    ->required()
                    ->maxLength(255),
            ]);
    }

    /**
     * Gestisce la creazione del record usando Data Objects.
     *
     * @param array<string, mixed> $data
     * @return \Modules\ModuleName\Models\User
     */
    public static function createRecord(array $data): User
    {
        // Converte dati del form in Data Object
        $userData = UserData::from($data);

        // Crea un nuovo utente dal Data Object
        $user = $userData->toModel();
        $user->save();

        return $user;
    }
}
```

## Anti-pattern da Evitare

### ❌ No: Proprietà Pubbliche Senza Readonly

```php
// ❌ MAI utilizzare proprietà pubbliche mutabili
namespace Modules\ModuleName\Data;

use Spatie\LaravelData\Data;

class UserData extends Data
{
    public string $name; // Non readonly, può essere modificata
    public string $email; // Non readonly, può essere modificata
}
```

### ❌ No: Oggetti Senza Costruttore Esplicito

```php
// ❌ MAI omettere il costruttore esplicito
namespace Modules\ModuleName\Data;

use Spatie\LaravelData\Data;

class UserData extends Data
{
    public readonly string $name;
    public readonly string $email;
    public readonly ?int $id = null;

    // Manca il costruttore esplicito
}
```

### ❌ No: Mancanza di Metodi Helper

```php
// ❌ MAI omettere metodi helper come fromModel e toModel
namespace Modules\ModuleName\Data;

use Spatie\LaravelData\Data;

class UserData extends Data
{
    public function __construct(
        public readonly string $name,
        public readonly string $email,
        public readonly ?int $id = null,
    ) {
    }

    // Mancano metodi helper per convertire da/a modello
}
```

## Best Practice

1. **Immutabilità**
   - I Data Objects DEVONO essere immutabili
   - Utilizzare SEMPRE `readonly` per le proprietà pubbliche
   - Creare nuove istanze per modificare i dati

2. **Validazione**
   - Utilizzare gli attributi di validazione di Spatie Laravel Data
   - Definire regole di validazione chiare e riutilizzabili
   - Includere messaggi di errore localizzati

3. **Conversione**
   - Fornire SEMPRE metodi per conversione da/a modelli
   - Utilizzare named constructor per chiarezza semantica
   - Gestire correttamente i tipi di dati e le relazioni

4. **Tipizzazione**
   - Tipizzazione rigorosa per tutti i metodi e proprietà
   - PHPDoc completi con tipi generics quando necessario
   - Metodi ben documentati con esempi di utilizzo

5. **Testing**
   - Scrivere test unitari per Data Objects
   - Testare la validazione e la conversione
   - Testare le relazioni e i casi limite

## Documentazione

Ogni modulo che utilizza Spatie Laravel Data deve includere:

1. **Documentazione Generale**
   - `Modules/ModuleName/docs/DATA_OBJECTS.md` - Spiegazione dei Data Objects del modulo

2. **Esempio di Documentazione**
   ```markdown
   # Data Objects in ModuleName

   Questo modulo utilizza Spatie Laravel Data per implementare il pattern DTO.

   ## UserData
   Rappresenta i dati di un utente.

   ### Proprietà
   - `name` (string): Nome dell'utente
   - `email` (string): Email dell'utente
   - `id` (int|null): ID dell'utente, null se nuovo

   ### Metodi
   - `fromModel(User $user)`: Crea un UserData da un modello User
   - `toModel()`: Converte il DTO in un modello User

   ### Esempio d'uso
   ```php
   // Creazione da array
   $userData = UserData::from([
       'name' => 'Mario Rossi',
       'email' => 'mario@example.com',
   ]);

   // Creazione da modello
   $userData = UserData::fromModel($user);

   // Conversione in modello
   $user = $userData->toModel();
   ```
   ```
