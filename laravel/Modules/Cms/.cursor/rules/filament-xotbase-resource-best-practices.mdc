---
description:
globs:
alwaysApply: false
---
## Gestione Doctor come User (STI/Parental)

Nel sistema <nome progetto> (e in tutti i moduli Xot), il dottore (**Doctor**) non è una tabella separata, ma un tipo di User gestito tramite Single Table Inheritance (STI) o Parental. La tabella di riferimento è sempre `users`, e il tipo è identificato dal campo `type` (stringa o enum).

- **Vietato** cercare la colonna `user_id` nella tabella `users` (non esiste).
- **Vietato** creare join o modelli duplicati per Doctor.
- **Tutta la logica di fetch, policy, tenancy, va fatta su User filtrando per type = 'doctor'** (o enum).

### Esempio di query corretta
```php
User::where('id', $id)->where('type', 'doctor')->firstOrFail();
// oppure con enum
User::where('id', $id)->where('type', UserTypeEnum::DOCTOR->value)->firstOrFail();
```

### Motivazione filosofica, politica, zen
- Un solo punto di verità: User è la tabella, Doctor è solo un "type"
- Nessuna duplicazione: niente modelli, tabelle, join inutili
- DRY, KISS, serenità del codice: tutto centralizzato, nessun errore di mapping, refactoring sicuro
- Politica: ogni modulo è autonomo, ma rispetta la centralizzazione delle entità
- Religione: "Non avrai altro modello di dottore all'infuori di User"

## Nota FullCalendar (2024)
- Anche per i widget FullCalendar, seguire la policy: solo classi custom che estendono FullCalendarWidget, override di config() e fetchEvents(), mai metodi fluenti su FullCalendarWidget::make().
