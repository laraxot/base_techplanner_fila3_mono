---
description:
globs:
alwaysApply: false
---
# Regole per Queueable Actions (Spatie)

## Regola Fondamentale
**NON utilizzare mai services tradizionali. Utilizzare SEMPRE Queueable Actions di Spatie.**

Repository: https://github.com/spatie/laravel-queueable-action

## When
- Stai implementando logica di business
- Hai bisogno di incapsulare operazioni complesse
- Devi gestire operazioni che potrebbero essere eseguite in background
- Stai creando funzionalità che devono essere testabili
- Hai logica che potrebbe beneficiare dell'esecuzione asincrona

## Then
- Crea una Queueable Action invece di un Service
- Estendi `QueueableAction` di Spatie
- Implementa il metodo `execute()` con la logica di business
- Usa dependency injection nel costruttore
- Aggiungi il trait `ShouldQueue` se l'azione deve essere eseguita in background
- Testa l'azione in isolamento

## Because
- Le Queueable Actions combinano il meglio di Actions e Queue
- Forniscono una singola responsabilità per ogni azione
- Sono facilmente testabili in isolamento
- Supportano l'esecuzione asincrona out-of-the-box
- Seguono i principi SOLID meglio dei services tradizionali
- Riducono l'accoppiamento e migliorano la manutenibilità

## Examples

### Azione Base
```php
<?php

namespace Modules\<nome progetto>\Actions;

use Spatie\QueueableAction\QueueableAction;
use Modules\<nome progetto>\Models\Appointment;
use Modules\<nome progetto>\Models\Patient;
use Modules\<nome progetto>\Models\Doctor;

class CreateAppointmentAction
{
    use QueueableAction;

    public function execute(
        Patient $patient,
        Doctor $doctor,
        string $title,
        \DateTime $startTime,
        \DateTime $endTime,
        array $options = []
    ): Appointment {
        return Appointment::create([
            'patient_id' => $patient->id,
            'doctor_id' => $doctor->id,
            'studio_id' => $doctor->studio_id,
            'title' => $title,
            'start_time' => $startTime,
            'end_time' => $endTime,
            'type' => $options['type'] ?? 'consultation',
            'status' => $options['status'] ?? 'scheduled',
            'notes' => $options['notes'] ?? '',
            'emergency' => $options['emergency'] ?? false,
        ]);
    }
}
```

### Azione con Queue
```php
<?php

namespace Modules\<nome progetto>\Actions;

use Spatie\QueueableAction\QueueableAction;
use Illuminate\Contracts\Queue\ShouldQueue;
use Modules\<nome progetto>\Models\Appointment;
use Modules\<nome progetto>\Notifications\AppointmentReminderNotification;

class SendAppointmentReminderAction implements ShouldQueue
{
    use QueueableAction;

    public function execute(Appointment $appointment): void
    {
        $appointment->patient->notify(
            new AppointmentReminderNotification($appointment)
        );

        $appointment->update([
            'reminder_sent_at' => now(),
        ]);
    }
}
```

### Utilizzo nelle Controller
```php
<?php

namespace Modules\<nome progetto>\Http\Controllers;

use Modules\<nome progetto>\Actions\CreateAppointmentAction;
use Modules\<nome progetto>\Actions\SendAppointmentReminderAction;

class AppointmentController extends Controller
{
    public function store(Request $request)
    {
        $appointment = CreateAppointmentAction::make()->execute(
            patient: $request->patient(),
            doctor: $request->doctor(),
            title: $request->title,
            startTime: $request->start_time,
            endTime: $request->end_time,
            options: $request->only(['type', 'status', 'notes', 'emergency'])
        );

        // Esegui in background
        SendAppointmentReminderAction::make()
            ->onQueue('notifications')
            ->execute($appointment);

        return response()->json($appointment);
    }
}
```

### Utilizzo nei Widget Filament
```php
<?php

namespace Modules\<nome progetto>\Filament\Widgets;

use Modules\<nome progetto>\Actions\GetAppointmentsForCalendarAction;
use Modules\<nome progetto>\Actions\UpdateAppointmentAction;

class DoctorCalendarWidget extends XotBaseFullCalendarWidget
{
    public function fetchEvents(array $fetchInfo): array
    {
        return GetAppointmentsForCalendarAction::make()->execute(
            startDate: $fetchInfo['start'],
            endDate: $fetchInfo['end'],
            doctorId: auth()->id(),
            studioId: Filament::getTenant()->id
        );
    }

    protected function handleEventUpdate(array $info): bool
    {
        return UpdateAppointmentAction::make()->execute(
            appointmentId: $info['event']['id'],
            data: [
                'start_time' => $info['event']['start'],
                'end_time' => $info['event']['end'],
            ]
        );
    }
}
```

### Testing
```php
<?php

namespace Tests\Unit\Actions;

use Tests\TestCase;
use Modules\<nome progetto>\Actions\CreateAppointmentAction;
use Modules\<nome progetto>\Models\Patient;
use Modules\<nome progetto>\Models\Doctor;

class CreateAppointmentActionTest extends TestCase
{
    public function test_creates_appointment_successfully()
    {
        $patient = Patient::factory()->create();
        $doctor = Doctor::factory()->create();

        $appointment = CreateAppointmentAction::make()->execute(
            patient: $patient,
            doctor: $doctor,
            title: 'Test Appointment',
            startTime: now()->addDay(),
            endTime: now()->addDay()->addHour()
        );

        $this->assertDatabaseHas('appointments', [
            'id' => $appointment->id,
            'patient_id' => $patient->id,
            'doctor_id' => $doctor->id,
            'title' => 'Test Appointment',
        ]);
    }
}
```

## Struttura Directory
```
Modules/<nome progetto>/
├── Actions/
│   ├── Appointments/
│   │   ├── CreateAppointmentAction.php
│   │   ├── UpdateAppointmentAction.php
│   │   ├── DeleteAppointmentAction.php
│   │   └── GetAppointmentsForCalendarAction.php
│   ├── Notifications/
│   │   ├── SendAppointmentReminderAction.php
│   │   └── SendAppointmentConfirmationAction.php
│   └── Reports/
│       ├── GenerateAppointmentReportAction.php
│       └── ExportAppointmentsAction.php
```

## Convenzioni di Naming
- Suffisso: `Action`
- Verbo + Sostantivo: `CreateAppointmentAction`, `SendEmailAction`
- Metodo principale: `execute()`
- Namespace: `Modules\{Module}\Actions\{Category}`

## Common Pitfalls

### ❌ Errori da Evitare
```php
// ERRATO: Usare services tradizionali
class AppointmentService
{
    public function createAppointment(...) { }
}

// ERRATO: Logica nel controller
class AppointmentController
{
    public function store(Request $request)
    {
        // Logica complessa qui...
        $appointment = new Appointment();
        // ...
    }
}

// ERRATO: Azioni troppo generiche
class AppointmentAction
{
    public function handle($type, $data) { }
}
```

### ✅ Approccio Corretto
```php
// CORRETTO: Queueable Action specifica
class CreateAppointmentAction
{
    use QueueableAction;

    public function execute(Patient $patient, Doctor $doctor, ...): Appointment
    {
        // Logica specifica e testabile
    }
}

// CORRETTO: Controller snello
class AppointmentController
{
    public function store(Request $request)
    {
        $appointment = CreateAppointmentAction::make()->execute(...);
        return response()->json($appointment);
    }
}
```

## Integrazione con il Sistema

### Dependency Injection
```php
class CreateAppointmentAction
{
    public function __construct(
        private AppointmentRepository $repository,
        private NotificationService $notifications
    ) {}

    public function execute(...): Appointment
    {
        $appointment = $this->repository->create(...);
        $this->notifications->sendConfirmation($appointment);
        return $appointment;
    }
}
```

### Middleware e Validation
```php
class CreateAppointmentAction
{
    use QueueableAction;

    public function execute(array $data): Appointment
    {
        $validated = validator($data, [
            'patient_id' => 'required|exists:users,id',
            'doctor_id' => 'required|exists:users,id',
            'start_time' => 'required|date|after:now',
            'end_time' => 'required|date|after:start_time',
        ])->validate();

        return Appointment::create($validated);
    }
}
```

## Performance e Monitoring

### Caching
```php
class GetAppointmentsForCalendarAction
{
    use QueueableAction;

    public function execute(string $startDate, string $endDate, int $doctorId): array
    {
        return cache()->remember(
            "calendar_appointments_{$doctorId}_{$startDate}_{$endDate}",
            300, // 5 minuti
            fn() => $this->fetchAppointments($startDate, $endDate, $doctorId)
        );
    }
}
```

### Logging e Monitoring
```php
class CreateAppointmentAction
{
    use QueueableAction;

    public function execute(...): Appointment
    {
        Log::info('Creating appointment', ['patient_id' => $patient->id]);

        $appointment = Appointment::create([...]);

        Log::info('Appointment created', ['appointment_id' => $appointment->id]);

        return $appointment;
    }
}
```

## Questa regola è FONDAMENTALE e deve essere sempre seguita in tutto il progetto <nome progetto>.
